--- FILE: ./include/ErrorHandler.hpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ErrorHandler.hpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/18 11:08:47 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/19 17:32:47 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ERRORHANDLER_HPP
#define ERRORHANDLER_HPP

/* Minimal error handling skeleton used across the project.
 * For now, only parser/config related errors are defined and thrown.
 */

#include <exception>
#include <string>

class ErrorHandler
{
  public:
    // Minimal set of error categories we currently care about
    enum ErrorCode {
        CONFIG_FILE_NOT_FOUND = 1,
        CONFIG_INVALID_PORT,
        CONFIG_MISSING_SEMICOLON,
        CONFIG_INVALID_DIRECTIVE,
        CONFIG_UNKNOWN_DIRECTIVE
    };

    // Lightweight exception carrying a message, code, and optional location
    class Exception : public std::exception {
      private:
        std::string _msg;
        int         _code;
        int         _line;      // -1 if unknown
        std::string _file;      // empty if unknown

      public:
        Exception(const std::string &message, int code);
        Exception(const std::string &message, int code, int line, const std::string &file);
        virtual ~Exception() throw();

        const char* what() const throw();
        int         code() const;             // ErrorCode value
        int         line() const;             // line number
        const std::string& file() const;      // file path
    };

    // Helper to build a formatted message with location context
    static std::string makeLocationMsg(const std::string &prefix, int line, const std::string &file);

    // Map an ErrorCode to a short label (no allocations beyond std::string construction)
    static const char* codeToString(int code);

    /* TODO:
     * - Add HTTP status mapping and default error page selection (SUBJECT: default error pages).
     * - Add validation helpers for all config directives (body size, methods, redirections, etc.).
     * - Centralize logging policy (respect non-blocking constraints, no errno-based flow after I/O).
     * - Extend codes for runtime server errors (socket/bind/listen, CGI, filesystem ops).
     * - Provide user-friendly messages and per-route context once routing is implemented.
     */
};

#endif

--- FILE: ./include/ConfigParser.hpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ConfigParser.hpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/13 13:20:54 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/22 17:06:03 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CONFIGPARSER_HPP
#define CONFIGPARSER_HPP

class ConfigParser
{
    private:
        std::string _configFile;
        int         _listenPort;
        std::string _root;
        std::vector<std::string> _index; // vector because there might be multiple index files
        std::string _serverName; 
        std::map<int, std::string> _errorPage; // to implement later
        size_t _clientMaxBodySize; // to implement later
        std::string _host; // to implement later
        std::string _location; // to implement later
        std::vector<std::string> _server; // to implement later, vector because there might be multiple server blocks
        
        // add more directives
        std::set<std::string> _allowedMethods; // to implement later, set because order does not matter
        std::vector<std::string> _lines;

        // Parse from a set of lines (expects raw lines; will trim/comment-strip internally)
        void        parseLines(const std::vector<std::string>& lines);

        // Per-directive parsers
        void        parseListen(const std::string &val, size_t lineNo);
        void        parseRoot(const std::string &val, size_t lineNo);
        void        parseIndex(const std::string &val, size_t lineNo);
        void        parseServerName(const std::string &val, size_t lineNo);
        void        parseClientMaxBodySize(const std::string &val, size_t lineNo);
        void        parseAllowedMethods(const std::string &val, size_t lineNo);
        void        parseErrorPage(const std::string &val, size_t lineNo);

        // Helpers to keep parseLines small
        std::string preprocessLine(const std::string &raw);
        bool        isBlockMarker(const std::string &line) const; // '{', '}', or contains '{'
        void        requireSemicolon(const std::string &line, size_t lineNo) const;
        std::string stripTrailingSemicolon(const std::string &line) const;
        bool        splitKeyVal(const std::string &line, std::string &key, std::string &val) const;
        void        handleDirective(const std::string &key, const std::string &val, size_t lineNo);
    public:
        ConfigParser();
        // Construct directly from lines (e.g., read elsewhere)
        ConfigParser(const std::vector<std::string>& lines);
        ~ConfigParser();

        // Parse minimal NGINX-like config supporting: listen, root, index
        // Returns true on success, false on failure.
        bool        parse(const std::string &path);

        // Accessors
        int                 getListenPort() const;
        const std::string&  getRoot() const;
        const std::string&  getIndex() const;
        const std::vector<std::string>& getLines() const;

        // TODO: implement error handling
        // TODO: implement parsing more directives (directives are the lines in the config file)
};

// Prototypes
std::string ltrim(const std::string &s);
std::string rtrim(const std::string &s);
std::string trim(const std::string &s);
std::string strip_comment(const std::string &s);

#endif
--- FILE: ./include/Common.hpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Common.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/13 13:21:03 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/13 15:15:35 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef COMMON_HPP
#define COMMON_HPP

/*A header file that includes common standard library headers and defines shared constants or 
macros used throughout the project.*/

#include <iostream>
#include <poll.h> // poll()
#include <sys/socket.h> // socket(), bind(), listen(), accept()
#include <unistd.h> // close()
#include <string> 
#include <fstream> // file stream: readFileToString()
#include <sstream> // string stream: sendAll()
#include <cctype> // character classification: isdigit()
#include <cstdlib> // standard library: exit()
#include <netinet/in.h> // internet address: struct sockaddr_in
#include <arpa/inet.h> // internet address: inet_addr()
#include <fcntl.h> // file control: O_RDONLY
#include <cstring> // string operations: memset()
#include <csignal> // signal handling: SIGINT, SIGTERM
#include <cerrno> // error handling: errno
#include <map>
#include <set>
#include <vector>
#include "ConfigParser.hpp" // configuration parser 
#include "HttpServer.hpp" // HTTP server
#include "ErrorHandler.hpp"
#include "HTTPparser.hpp" // parser for HTTP requests sent by the client

// create a DEBUG macro so that if it's true the debugging mode in the code will print stuff
#ifndef DEBUG
#define DEBUG true
#endif
#if DEBUG
#define DEBUG_PRINT(x) std::cout << x << std::endl
#else
#define DEBUG_PRINT(x)
#endif

#endif

--- FILE: ./include/HTTPparser.hpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HTTPparser.hpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/22 17:32:20 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/22 17:32:20 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef HTTPPARSER_HPP
#define HTTPPARSER_HPP

class HTTPparser
{
    private:
        std::string _HTTPrequest; // raw requested data, this might need to change type because large requests like POST might be too large for a string
        std::vector<std::string> _lines;
        std::string _method; // HTTP Method GET, POST, DELETE
        std::string _path; // Path of the requested resource
        std::string _version; // HTTP Version
        std::map<std::string, std::string> _headers; // Headers
        std::string _body; // Body
        std::string _buffer; // buffer to account for the sequential and potentially incremental nature of HTTP requests for non-blocking servers
        size_t _contentLength; // content length of the request
        std::string _errorStatusCode;         
    public:
        HTTPparser();
        ~HTTPparser();
};

#endif

--- FILE: ./include/HttpServer.hpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpServer.hpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/13 14:20:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/13 15:15:00 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef HTTPSERVER_HPP
#define HTTPSERVER_HPP

class HttpServer
{
private:
    int         _port;
    std::string _root;
    std::string _index;

public:
    HttpServer(int port, const std::string &root, const std::string &index);
    ~HttpServer();

    // Start a very simple blocking server for demo purposes
    // Returns 0 on normal exit, non-zero on error
    // TODO: make this non-blocking. Achieve this by using poll() to wait for connections.
    int start();
};

#endif

--- FILE: ./html/uploads/index.html ---
<html>
<p>Simple HTML page</p>
</html>

--- FILE: ./html/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>It works!</title>
</head>
<body>
  <h1>It works!</h1>
  <p>Serving index.html</p>
</body>
</html>

--- FILE: ./src/main.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/12 12:44:17 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/16 15:51:40 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/Common.hpp"
#include "../include/HttpServer.hpp"

// implement later try...catch blocks
int main(int argc, char **argv)
{
    // Accept 0 or 1 argument. If none, use default config path.
    std::string configPath = "conf/default.conf";
    if (argc == 2)
        configPath = argv[1];
    else if (argc > 2)
    {
        std::cerr << "Usage: " << argv[0] << " conf/[config_file].conf" << std::endl;
        return 1;
    }

    ConfigParser parser;
    if (!parser.parse(configPath))
        return 1;

    if(DEBUG){
    // For now, just show parsed values to verify the minimal parser works
    std::cout << "Config loaded from: " << configPath << std::endl;
    std::cout << "listen: " << parser.getListenPort() << std::endl;
    std::cout << "root:   " << parser.getRoot() << std::endl;
    std::cout << "index:  " << parser.getIndex() << std::endl;

    // Demonstrate access to all raw lines read from the config file
    const std::vector<std::string>& lines = parser.getLines();
    for (size_t i = 0; i < lines.size(); ++i)
        std::cout << "CFG[" << i << "]: " << lines[i] << std::endl;
    }
    std::string example = "print test";
    DEBUG_PRINT("DEBUG_PRINT: " << example << std::endl);
    HttpServer server(parser.getListenPort(), parser.getRoot(), parser.getIndex());
    return server.start();
}

--- FILE: ./src/configParser/Trim.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Trim.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/16 17:32:38 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/16 17:32:38 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/Common.hpp"

// helper functions, trim whitespace from left
std::string ltrim(const std::string &s)
{
    std::string::size_type i = 0;
    while (i < s.size() && (s[i] == ' ' || s[i] == '\t' || s[i] == '\r')) 
        i++;
    return s.substr(i);
}

// helper functions, trim whitespace from right
std::string rtrim(const std::string &s)
{
    if (s.empty())
        return s;
    std::string::size_type i = s.size();
    while (i > 0 && (s[i-1] == ' ' || s[i-1] == '\t' || s[i-1] == '\r'))
        i--;
    return s.substr(0, i);
}

// helper functions, trim whitespace from both sides
std::string trim(const std::string &s)
{ 
    return rtrim(ltrim(s)); 
}

// helper functions, strip comments
std::string strip_comment(const std::string &s)
{
    std::string::size_type pos = s.find('#');
    if (pos == std::string::npos)
        return s;
    return s.substr(0, pos);
}
--- FILE: ./src/configParser/ParserHelpers.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ParserHelpers.cpp                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 17:35:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/19 17:42:19 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/Common.hpp"

std::string ConfigParser::preprocessLine(const std::string &raw)
{
    std::string line = strip_comment(raw);
    line = trim(line);
    return line;
}

bool ConfigParser::isBlockMarker(const std::string &line) const
{
    return (line == "}" || line.find('{') != std::string::npos);
}

void ConfigParser::requireSemicolon(const std::string &line, size_t lineNo) const
{
    if (line.empty() || line[line.size() - 1] != ';') 
    {
        std::string msg = ErrorHandler::makeLocationMsg("Missing ';' at end of directive", (int)lineNo, this->_configFile);
        throw ErrorHandler::Exception(msg, ErrorHandler::CONFIG_MISSING_SEMICOLON, (int)lineNo, this->_configFile);
    }
}

std::string ConfigParser::stripTrailingSemicolon(const std::string &line) const
{
    if (!line.empty() && line[line.size() - 1] == ';')
        return line.substr(0, line.size() - 1);
    return line;
}

bool ConfigParser::splitKeyVal(const std::string &line, std::string &key, std::string &val) const
{
    std::string::size_type sp = line.find(' ');
    if (sp == std::string::npos) return false;
    key = trim(line.substr(0, sp));
    val = trim(line.substr(sp + 1));
    return true;
}

void ConfigParser::handleDirective(const std::string &key, const std::string &val, size_t lineNo)
{
    if (key == "listen")
        parseListen(val, lineNo);
    else if (key == "root")
        parseRoot(val, lineNo);
    else if (key == "index")
        parseIndex(val, lineNo);
    else if (key == "server_name")
        parseServerName(val, lineNo);
    else if (key == "client_max_body_size")
        parseClientMaxBodySize(val, lineNo);
    else if (key == "allowed_methods")
        parseAllowedMethods(val, lineNo);
    else if (key == "error_page")
        parseErrorPage(val, lineNo);
    else {
        // Unknown directive: ignore non-fatally for now
        DEBUG_PRINT("Unknown directive '" << key << "' (ignored)");
    }
    // TODO: implement more directives
}

--- FILE: ./src/configParser/Getters.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Getters.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/16 17:30:53 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/16 17:30:53 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/Common.hpp"

int ConfigParser::getListenPort() const 
{ 
    return _listenPort; 
}

const std::string& ConfigParser::getRoot() const 
{ 
    return _root; 
}

const std::string& ConfigParser::getIndex() const 
{ 
    if (!_index.empty())
        return _index.front();
    static const std::string kEmpty;
    return kEmpty;
}

const std::vector<std::string>& ConfigParser::getLines() const
{
    return _lines;
}
--- FILE: ./src/configParser/directives/ParseAllowedMethods.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ParseAllowedMethods.cpp                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 15:05:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/19 17:29:37 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/Common.hpp"

void ConfigParser::parseAllowedMethods(const std::string &val, size_t lineNo)
{
    // Split by spaces and validate methods
    std::istringstream iss(val);
    std::string tok;
    while (iss >> tok) 
    {
        if (tok != "GET" && tok != "POST" && tok != "DELETE") 
        {
            std::string msg = ErrorHandler::makeLocationMsg(std::string("Unsupported method in allowed_methods: ") + tok,
                                                            (int)lineNo, this->_configFile);
            throw ErrorHandler::Exception(msg, ErrorHandler::CONFIG_INVALID_DIRECTIVE, (int)lineNo, this->_configFile);
        }
        this->_allowedMethods.insert(tok);
        DEBUG_PRINT("Added allowed_method -> '" << tok << "'");
    }
    if (this->_allowedMethods.empty()) 
    {
        std::string msg = ErrorHandler::makeLocationMsg("allowed_methods requires at least one method", (int)lineNo, this->_configFile);
        throw ErrorHandler::Exception(msg, ErrorHandler::CONFIG_INVALID_DIRECTIVE, (int)lineNo, this->_configFile);
    }
}

--- FILE: ./src/configParser/directives/ParseErrorPage.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ParseErrorPage.cpp                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 15:05:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/20 17:26:59 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/Common.hpp"

void ConfigParser::parseErrorPage(const std::string &val, size_t lineNo)
{
    // Syntax: error_page <code> [code ...] <uri>
    std::istringstream iss(val);
    std::vector<std::string> parts;
    std::string tok;
    while (iss >> tok) parts.push_back(tok);
    if (parts.size() < 2) 
    {
        std::string msg = ErrorHandler::makeLocationMsg("error_page requires at least a code and a target", (int)lineNo, this->_configFile);
        throw ErrorHandler::Exception(msg, ErrorHandler::CONFIG_INVALID_DIRECTIVE, (int)lineNo, this->_configFile);
    }
    std::string target = parts.back();
    // Create for loop over each code in parts except the last part (which is the target):
    //     Parse the code 
    //     If invalid, throw an exception for CONFIG_INVALID_DIRECTIVE
    //     Otherwise, set _errorPage to the raget
}

--- FILE: ./src/configParser/directives/ParseRoot.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ParseRoot.cpp                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 15:05:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/19 15:05:00 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/Common.hpp"

void ConfigParser::parseRoot(const std::string &val, size_t /*lineNo*/)
{
    this->_root = val;
    DEBUG_PRINT("Applied root -> '" << this->_root << "'");
}

--- FILE: ./src/configParser/directives/ParseClientMaxBodySize.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ParseClientMaxBodySize.cpp                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 15:05:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/21 15:21:06 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/Common.hpp"

void ConfigParser::parseClientMaxBodySize(const std::string &val, size_t lineNo)
{
    if (val.empty())
    {
        std::string msg = ErrorHandler::makeLocationMsg("Missing value for client_max_body_size directive",
                                                        (int)lineNo, this->_configFile);
        throw ErrorHandler::Exception(msg, ErrorHandler::CONFIG_INVALID_DIRECTIVE, (int)lineNo, this->_configFile);
    }
    // Accept formats like: 1024, 10k, 1m, 1g (case-insensitive); store in bytes
    // Ensure a value exists (error if missing)

    // Split the input into a number part and a multiplier (based on suffix like k, m, or g)

    // Parse the numeric value, validate

    // Check for overflow by confirming reverse calculation is consistent

    // Store the final byte value in the config struct

    // Optionally print debug info
}

--- FILE: ./src/configParser/directives/ParseIndex.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ParseIndex.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 15:05:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/19 15:05:00 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/Common.hpp"

void ConfigParser::parseIndex(const std::string &val, size_t /*lineNo*/)
{
    this->_index.push_back(val);
    DEBUG_PRINT("Applied index -> '" << this->_index.back() << "'");
}

--- FILE: ./src/configParser/directives/ParseListen.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ParseListen.cpp                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 15:05:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/19 18:18:21 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/Common.hpp"

void ConfigParser::parseListen(const std::string &val, size_t lineNo)
{
    std::string::size_type colonPos = val.rfind(':');
    std::string portStr = (colonPos == std::string::npos) ? val : val.substr(colonPos + 1);
    this->_listenPort = std::atoi(portStr.c_str());
    if (this->_listenPort <= 0)
    {
        std::string msg = ErrorHandler::makeLocationMsg(std::string("Invalid port number: ") + portStr,
                                                        (int)lineNo, this->_configFile);
        throw ErrorHandler::Exception(msg, ErrorHandler::CONFIG_INVALID_PORT, (int)lineNo, this->_configFile);
    }
    DEBUG_PRINT("Applied listen -> " << this->_listenPort);
    // If host was provided (e.g., 127.0.0.1:8080), capture it
    if (colonPos != std::string::npos) {
        std::string host = trim(val.substr(0, colonPos));
        if (!host.empty()) {
            this->_host = host;
            DEBUG_PRINT("Applied host -> '" << this->_host << "'");
        }
    }
}

--- FILE: ./src/configParser/directives/ParseServerName.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ParseServerName.cpp                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 15:05:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/19 15:05:00 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/Common.hpp"

void ConfigParser::parseServerName(const std::string &val, size_t /*lineNo*/)
{
    this->_serverName = val;
    DEBUG_PRINT("Applied server_name -> '" << this->_serverName << "'");
}

--- FILE: ./src/configParser/ConfigParser.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ConfigParser.cpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/19 17:38:04 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/19 17:38:04 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/Common.hpp"

// constructor
ConfigParser::ConfigParser()
    : _configFile("")
    , _listenPort(8080)
    , _root("html")
    , _index()
    , _serverName("")
    , _errorPage()
    , _clientMaxBodySize(1024 * 1024) // default 1 MiB
    , _host("")
    , _allowedMethods()
    , _lines()
{
    _index.push_back("index.html");
}

// construct from lines
ConfigParser::ConfigParser(const std::vector<std::string>& lines)
    : _configFile("")
    , _listenPort(8080)
    , _root("html")
    , _index()
    , _serverName("")
    , _errorPage()
    , _clientMaxBodySize(1024 * 1024) // default 1 MiB
    , _host("")
    , _allowedMethods()
    , _lines()
{
    _index.push_back("index.html");
    parseLines(lines);
}
// destructor
ConfigParser::~ConfigParser() {}

// helper: parse from given lines
// Minimal validation with error throwing for invalid syntax/values
void ConfigParser::parseLines(const std::vector<std::string>& lines)
{
    this->_lines.clear();

    for (size_t i = 0; i < lines.size(); ++i)
    {
        const std::string raw = lines[i];
        DEBUG_PRINT("Line " << i << " raw: '" << raw << "'");
        std::string line = preprocessLine(raw);
        DEBUG_PRINT("Line " << i << " preprocessed: '" << line << "'");

        if (!line.empty())
            this->_lines.push_back(line);

        if (line.empty())
        {
            DEBUG_PRINT("Line " << i << " skipped: empty after trim/comment");
            continue;
        }

        if (isBlockMarker(line)) {
            DEBUG_PRINT("Line " << i << " skipped: brace/block marker");
            continue;
        }

        requireSemicolon(line, i + 1);
        line = stripTrailingSemicolon(line);

        std::string key, val;
        if (!splitKeyVal(line, key, val))
            continue;
        DEBUG_PRINT("Directive key='" << key << "' val='" << val << "'");

        handleDirective(key, val, i + 1);
    }
}

// parse config file
bool ConfigParser::parse(const std::string &path)
{
    this->_configFile = path;
    DEBUG_PRINT("Opening config file: '" << path << "'");

    try {
        std::ifstream in(path.c_str());
        if (!in.good())
        {
            std::string msg = ErrorHandler::makeLocationMsg(std::string("Failed to open config file: ") + path, -1, path);
            throw ErrorHandler::Exception(msg, ErrorHandler::CONFIG_FILE_NOT_FOUND);
        }

        std::vector<std::string> rawLines;
        std::string line;
        while (std::getline(in, line))
            rawLines.push_back(line);
        DEBUG_PRINT("Read " << rawLines.size() << " lines from file");

        parseLines(rawLines);
        DEBUG_PRINT("Finished parsing file: '" << path << "'");
        return true;
    }
    catch (const ErrorHandler::Exception &e) {
        std::cerr << "[CONFIG ERROR] (" << ErrorHandler::codeToString(e.code()) << ") " << e.what() << std::endl;
        return false;
    }
}

--- FILE: ./src/server/HttpServer.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HttpServer.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/13 14:20:00 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/16 17:40:24 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/Common.hpp"

HttpServer::HttpServer(int port, const std::string &root, const std::string &index)
: _port(port), _root(root), _index(index) {}

HttpServer::~HttpServer() {}

// read file to string, return empty string on error. Uses binary mode to preserve file contents.
static std::string readFileToString(const std::string &path)
{
    std::ifstream ifs(path.c_str(), std::ios::in | std::ios::binary);
    if (!ifs.good()) 
    {
        std::cerr << "Failed to open file: " << path << std::endl;
        return std::string();
    }
    std::ostringstream ss;
    ss << ifs.rdbuf();
    return ss.str();
}

// send all data to socket, continue until all data is sent or error occurs
static void sendAll(int fd, const char *data, size_t len)
{
    size_t sent = 0;
    while (sent < len)
    {
        ssize_t n = send(fd, data + sent, len - sent, 0);
        if (n <= 0) break;
        sent += (size_t)n;
    }
}

// start the server, return 0 on success, non-zero on error. Blocks until server is stopped.
// This is a very simple blocking server for demo purposes.
// TODO: make this non-blocking. Achieve this by using poll() to wait for connections.
// Global stop flag set by signal handlers
static volatile sig_atomic_t g_stop = 0;

static void handle_stop_signal(int)
{
    g_stop = 1;
}

int HttpServer::start()
{
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0)
    {
        std::cerr << "socket() failed" << std::endl;
        return 1;
    }

    // this is to allow the server to be restarted quickly without waiting for the port to be released
    // it works by allowing the socket to be bound to an address that is already in use
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    // this struct is defined in <netinet/in.h>
    struct sockaddr_in addr;
    // this block of code is to initialize the struct to 0, because it is not initialized by default
    std::memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET; // AF_INET is the address family for IPv4
    addr.sin_addr.s_addr = htonl(INADDR_ANY); // INADDR_ANY is a special address that means "any address"
    addr.sin_port = htons((uint16_t)_port); // htons() converts the port number to network byte order

    // bind the socket to the address, we need to bind the socket to the address because 
    // we want to listen on a specific port
    if (bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0)
    {
        std::cerr << "bind() failed on port " << _port << std::endl;
        close(server_fd);
        return 1;
    }

    // listen for connections, we need to listen for connections because we want to accept connections
    if (listen(server_fd, 10) < 0)
    {
        std::cerr << "listen() failed" << std::endl;
        close(server_fd);
        return 1;
    }

    std::cout << "Serving " << _root << "/" << _index << " on http://localhost:" << _port << "/" << std::endl;

    // Install simple signal handlers to allow graceful shutdown in CI
    std::signal(SIGINT, handle_stop_signal);
    std::signal(SIGTERM, handle_stop_signal);

    // Single-request mode for CI when WEBSERV_ONCE=1
    const char* onceEnv = std::getenv("WEBSERV_ONCE");
    bool serveOnce = (onceEnv && std::string(onceEnv) == "1");
    size_t servedCount = 0;

    // we need infinite loop to keep the server running
    while(true)
    {
        struct sockaddr_in cli; // client address that is connecting to the server
        socklen_t clilen = sizeof(cli); 
        int cfd = accept(server_fd, (struct sockaddr*)&cli, &clilen); // accept the connection
        if (cfd < 0)
        {
            if (errno == EINTR && g_stop)
                break; // interrupted by signal, time to stop
            continue;
        }

        char buf[4096]; // buffer to store the request
        std::memset(buf, 0, sizeof(buf));
        ssize_t n = recv(cfd, buf, sizeof(buf)-1, 0);
        if (n <= 0)
        {
            close(cfd);
            continue;
        }

        // Very basic request parsing (GET only)
        std::string req(buf, (size_t)n);
        std::string path = "/";
        if (req.compare(0, 4, "GET ") == 0)
        {
            std::string::size_type sp = req.find(' ');
            if (sp != std::string::npos)
            {
                std::string::size_type sp2 = req.find(' ', sp + 1);
                if (sp2 != std::string::npos)
                    path = req.substr(sp + 1, sp2 - (sp + 1));
            }
        }

        std::string filePath;
        if (path == "/" || path.empty())
            filePath = _root + "/" + _index;
        else
        {
            if (path.size() > 0 && path[0] == '/')
                filePath = _root + path; // maps "/foo" -> "root/foo"
            else
                filePath = _root + "/" + path;
        }

        std::string body = readFileToString(filePath);
        std::ostringstream resp;
        if (!body.empty())
        {
            resp << "HTTP/1.1 200 OK\r\n";
            resp << "Content-Type: text/html; charset=utf-8\r\n";
            resp << "Content-Length: " << body.size() << "\r\n";
            resp << "Connection: close\r\n\r\n";
            resp << body;
        }
        else
        {
            std::string notFound = "<h1>404 Not Found</h1>";
            resp << "HTTP/1.1 404 Not Found\r\n";
            resp << "Content-Type: text/html; charset=utf-8\r\n";
            resp << "Content-Length: " << notFound.size() << "\r\n";
            resp << "Connection: close\r\n\r\n";
            resp << notFound;
        }

        std::string respStr = resp.str();
        sendAll(cfd, respStr.c_str(), respStr.size());
        close(cfd);

        // In CI single-request mode, exit after first served request
        if (serveOnce)
        {
            ++servedCount;
            if (servedCount >= 1)
                break;
        }
    }

    close(server_fd);
    return 0;
}

--- FILE: ./src/error_handling/Getters.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Getters.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/18 11:46:14 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/18 11:46:14 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/Common.hpp"

int ErrorHandler::Exception::code() const 
{ 
    return _code; 
}

int ErrorHandler::Exception::line() const 
{ 
    return _line; 
}
const std::string& ErrorHandler::Exception::file() const 
{ 
    return _file; 
}
--- FILE: ./src/error_handling/ErrorHandler.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ErrorHandler.cpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/18 11:14:28 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/18 11:46:35 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/ErrorHandler.hpp"
#include <sstream>

// Construct an exception with just message and code
ErrorHandler::Exception::Exception(const std::string &message, int code)
  : _msg(message), _code(code), _line(-1), _file("") {}

// Construct an exception with full location context
ErrorHandler::Exception::Exception(const std::string &message, int code, int line, const std::string &file)
  : _msg(message), _code(code), _line(line), _file(file) {}

ErrorHandler::Exception::~Exception() throw() {}

const char* ErrorHandler::Exception::what() const throw()
{
    return _msg.c_str();
}

// Helper: format a location-aware prefix
std::string ErrorHandler::makeLocationMsg(const std::string &prefix, int line, const std::string &file)
{
    std::ostringstream oss;
    oss << prefix;
    if (!file.empty()) {
        oss << " [file: " << file << "]";
    }
    if (line >= 0) {
        oss << " [line: " << line << "]";
    }
    return oss.str();
}

const char* ErrorHandler::codeToString(int code)
{
    switch (code) {
        case CONFIG_FILE_NOT_FOUND:   
            return "CONFIG_FILE_NOT_FOUND";
        case CONFIG_INVALID_PORT:     
            return "CONFIG_INVALID_PORT";
        case CONFIG_MISSING_SEMICOLON:
            return "CONFIG_MISSING_SEMICOLON";
        case CONFIG_INVALID_DIRECTIVE:
            return "CONFIG_INVALID_DIRECTIVE";
        case CONFIG_UNKNOWN_DIRECTIVE:
            return "CONFIG_UNKNOWN_DIRECTIVE";
        default:                      
            return "UNKNOWN_ERROR_CODE";
    }
}
--- FILE: ./src/httpParser/HTTPparser.cpp ---
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   HTTPparser.cpp                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pmolzer <pmolzer@student.42berlin.de>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/22 17:34:05 by pmolzer           #+#    #+#             */
/*   Updated: 2025/08/22 17:34:05 by pmolzer          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/Common.hpp"

HTTPparser::HTTPparser()
{}

HTTPparser::~HTTPparser()
{}

